import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState, AppThunk } from "./store";

import { idText } from "typescript";

export interface Expense {
  id: string;
  charge: string;
  amount: string;
}

const initialState: Expense[] = [];

export const expenseSlice = createSlice({
  name: "expenses",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    clearExpenses: () => {
      // state.splice(0, state.length);  or
      return [];
    },
    addExpense: (state, action: PayloadAction<Expense>) => {
      state.push(action.payload);
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    deleteExpense: (state, action: PayloadAction<Expense["id"]>) =>
      state.filter((item) => action.payload !== item.id),

    editExpense: (state, action: PayloadAction<Expense>) => {
      let indexOfItem = state.findIndex(
        (item) => action.payload.id === item.id
      );
      state.splice(indexOfItem, 1, action.payload);
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
});

export const { clearExpenses, addExpense, deleteExpense, editExpense } =
  expenseSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectExpenses = (state: RootState) => state.expenses;
export const selectFirstExpense = (state: RootState) => state.expenses[0];

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

export default expenseSlice.reducer;
